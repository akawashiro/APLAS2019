% !TEX root = ../main.tex

\section{Introduction}

\subsection{Multi-stage Programming}

% \subsubsection{多段階計算とは何か?}

Multi-stage programming enables programmers to generate and run fragments of code at runtime.
We can treat a piece of code as a value with multi-stage programming.
It means code fragments can be substituted into variables, combined and run at runtime.
Multi-stage programming improves the performance of programs by generating optimized code for a given input at runtime. \cite{taha2007gentle}
% MetaOCamlを例に挙げて多段階計算について説明する

MetaOCaml~\cite{calcagno2003implementing}\cite{oleg2014} provides features for multi-stage programming, which are brackets, escape, run, and CSP.
Brackets, written \verb|.< e >.| in MetaOCaml, makes a code value from \verb|e|.
Run, written \verb| run e | in MetaOCaml, runs a code value of \verb|e| and restore \verb|e|.
Escape, written \verb| .~ e | in MetaOCaml, expands a code value of \verb|e|.
Unlike run, escape is supposed to use in a fragment of code, that is, escape cannot be used as an alternative of run.
For example, the following MetaOCaml expression

\begin{verbatim}
      let plusone = .< fun x -> x + 1 >. in .< .~plusone 2 >.
\end{verbatim}
evaluates to \verb|.< (fun x -> x + 1) 2 >.|. We can get the result with run.
\begin{verbatim}
    run (let plusone = .< fun x -> x + 1 >. in .< .~plusone 2 >.)
\end{verbatim}
is reduced to 3.

% \subsubsection{CSPに関する補足説明}

Cross-stage persistence (CSP) is another primitive of multi-stage programming, which enable us to embed computed values into a code value.
This is an example of CSP.
\begin{verbatim}
               let plusone = fun x -> x + 1 in
               let y = plusone 2 in  .< y >.
\end{verbatim}
This program evaluates to \verb|.< 3 >.| not  \verb|.< plusone 2 >.|.
This is because the variable \verb|y| is introduced into a code fragment using CSP.
Therefore, the variable \verb|y| is embedded after it was calculated.
CSP is very important when we write practical programs 
because CSP enables us to use library functions in code fragments as in \verb|.<List.combine [1;2] ['a';'b']>.|.

% \subsubsection{多段階計算のメリットをべき乗の例を用いて説明する}

The main application of multi-stage calculi is program optimization. 
A famous example is power functions.
Usual power functions take two arguments, which are the base and the exponent.
We can make a specialized power function for given exponents with multi-stage programming and 
optimize them by unrolling a loop in functions for given exponents.
The optimized power function for the exponent of \verb|3| looks like \verb|power3 = fun x -> x * x * x|.
\verb|power3| is faster than ordinary \verb|power| function because it contains no loop.
Multi-stage programming can optimize functions which take more than two arguments 
by generating a code fragment optimized to a given argument.

% 多段階計算の型理論の既存研究の紹介

Existing type systems for multi-stage calculi ensure that
the generated code is well-typed and code generation and evaluation are performed in the intended order.
For example, the type system of MetaOCaml~\cite{taha1999multi} classify expressions in a program
with the depth of brackets in order to handle them appropriately.
In $\lambda^\triangleright$ by Tsukada and Igarashi~\cite{Tsukada},
they use environment classifier to classify and 
succeeded in recognizing code values which are run safely at type-checking time.

% ベクトル計算も高速化できる

Multi-stage programming can also optimize vector calculation.
For example, \verb|vadd| function, which takes two vectors and return the sum of them,
is implemented with a loop in many cases.
We can unroll \verb|vadd| function for a given vector length and optimize it with multi-stage programming.

% 多段階計算で生成したコードは特殊化されているが故に問題も多い

However, there is a sever problem in functions which are optimized by multi-stage programming.
Although unrolled \verb|vadd| function is optimized, we cannot use it for different vector length.
For example, when you optimize for the length of 5, you shouldn't use it for vectors of 3 lengths.
Otherwise, we will get a exception.
This problem is serious but existing type systems for multi-stage calculi cannot prevent it.

\subsection{Multi-stage Programming with Dependent Types}

% 依存型とは何か?

One natural idea to address this problem is the introduction of dependent types.
Dependent types are types which are dependent on values.
We can use dependent types for securer programming like Xi and Pfenning \cite{Xi98}.
For example, we can realize vectors with their sizes with them.
\begin{verbatim}
        Vector :: Int -> *
\end{verbatim}
\verb|Vector| is a type constructor which takes the length of vectors, that is, 
\verb|Vector 3| is a type for vectors whose lengths are 3.
If \verb|vadd| function has the type of \verb|Vector n -> Vector n -> Vector n| for any positive number \verb|n|,
we can confirm the two arguments of \verb|vadd| function has the same length.
% \red{secure programming? finer grained typing? とか}

As we pointed out in the above section,
functions optimized with multi-stage programming can take only restricted values as arguments.
When you optimize \verb|vadd| function for the length of 5, you should it only for 5 length vectors.
We introduce dependent types into a multi-stage calculus
so that the type system can guarantee optimized functions are used properly.
Although there is a trial to combine multi-stage programming and dependent type by Brady and Hammond~\cite{brady2006dependently},
they didn't give a formal definition and properties for the calculus.

In this paper, we design a new multi-stage calculus \LMD by 
merging dependent types into existing multi-stage calculus \LTP\cite{Hanada2014}.
\LMD is multi-stage calculus which contains dependent types.
\LMD makes multi-stage programming safer with the power of dependent types.
Our technical contribution are summarized as follows:
\begin{itemize}
        \item we give the formal definition of \LMD with its syntax, 
        type system which contains type equivalence, full, reduction, and staged reduction;
        \item for the full reduction, we prove preservation, strong normalization, and confluence
        \item fot the staged reduction, we prove unique decomposition and progress.
\end{itemize}

\subsection{Organization of the Paper}

The organization of this paper is the following.
Section \ref{sec:informal-overview} gives an informal overview of \LMD.
Section \ref{sec:formal-definition} defines \LMD and
Section \ref{sec:properties} shows the properties of \LMD including preservation, strong normalization, confluence, and progress.
Section \ref{sec:related-work} discusses related work.
Finally, we conclude this paper in Section \ref{sec:conclusion} and discusses future work.
