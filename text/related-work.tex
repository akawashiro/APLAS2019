% !TEX root = ../main.tex

\section{Related Work \label{sec:related-work}}

MetaOCaml is a programming language with quoting, unquoting, run, and
CSP.  Kiselyov give many applications of MetaOCaml in \cite{8384206},
which includes filtering in signal processing, matrix-vector product,
and DSL compiler.  

% 多段階計算の歴史

Theoretical studies on multi-stage programming owe a lot to seminal
work by Davies and Pfenning~\cite{DaviesPfenning01JACM} and
Davies~\cite{davies1996temporal}, which found Curry-Howard
correspondence between multi-stage calculi and modal logic.  In
particular, Davies' $\lambda^\circ$~\cite{davies1996temporal} has been
a basis for multi-stage calculi with quasi-quotation.  $\lambda^\circ$
did not have operators for run and CSP; a few
studies~\cite{benaissa1999logical,MoggiTahaBenaissaSheard99ESOP}
enhanced and improved $\lambda^\circ$ towards the development of a
type-safe multi-stage calculus with quasi-quotation, run, and CSP,
which were proposed by Taha and Sheard as constructs for multi-stage
programming~\cite{MetaML}.
% Benaissa et al.~\cite{benaissa1999logical} study the relationship between a multi-stage calculus and category theory or modal logic.
% Taha and Sheard introduced run and CSP to a multi-stage calculus in 
Finally, Taha and Nielsen invented the concept of environment
classifiers~\cite{taha2003environment} and developed a typed calculus
$\lambda^\alpha$, which was equipped with all the features above in a
type sound manner and formed a basis of earlier versions of MetaOCaml.
A different approach to type-safe multi-stage programming with
different semantics for quasi-quotations has been studied by Kim, Yi,
and Calcagno~\cite{DBLP:conf/popl/KimYC06}.

Later, Tsukada and Igarashi~\cite{Tsukada} found correspondence
between a variant of \(\lambda^\alpha\) called $\lambda^\TW$
and modal logic and showed that run could be represented as a special
case of application of a transition abstraction ($\Lambda\alpha$) to
the empty sequence $\varepsilon$.  Hanada and
Igarashi~\cite{Hanada2014} developed \LTP as an extension
$\lambda^\TW$ with CSP.
% and discuss code residualization which
% allows us to dump the quoted code into an external file.

% 他段階計算の機能拡張


% 多段階計算の応用



% 依存型の歴史

There is much work on dependent types and most of them are affected by
the pioneering work by Martin-L\"{o}f~\cite{martin1973intuitionstic}.
Among many dependent type systems such as
$\lambda^\Pi$~\cite{Meyer1986}, Calculus of
Constructions~\cite{coquand:inria-00076024}, and Edinburgh
LF~\cite{harper1993framework}, we base our work on \LLF~\cite{attapl}
(which is quite close to $\lambda^\Pi$ and Edinburgh LF) due to its
simplicity.  It has been well known that dependent types are useful to
express detailed properties of data structure at the type level such
as the size of data structures~\cite{Xi98} and typed abstract syntax
trees~\cite{DBLP:conf/dsl/LeijenM99,DBLP:conf/popl/XiCC03}.  The
vector addition discussed in Section~\ref{sec:formal} is also such an
example.

% 依存型の応用

% Practical applications of dependent types have been also studied.
% One can use dependent types in programming languages such as Idris~\cite{brady2013idris} or
% interactive theorem provers such as Coq~\cite{09thecoq} based on \cite{coquand:inria-00076024}.
% In Xi and Pfenning~\cite{Xi98}, they extended SML with restricted dependent types
% and succeeded in reducing the bounds checking of arrays.
% In Xi and Harper~\cite{xi2001dependently}, they design a type system for an assembly language and
% it is useful for speed up.
% Xi also gave dead code elimination and loop unrolling as applications
%  of dependent types~\cite{xi1999dependent}.

% 関連研究との比較

Although there are studies on combinations of multi-stage programming and other programming features such as mutable cells~\cite{kiselyov2016refined},
control operators~\cite{KameyamaKiselyovShan09PEPM,oishi2017staging},
a combination with dependent types has been little studied.
One exception is Brady and Hammond~\cite{brady2006dependently},
who have discussed a
combination of dependently typeed programming with staging in the
style of MetaOCaml to implement a staged interpreter, which is
statically guaranteed to generate well typed code.  However, they
focused on concrete programming examples and there is no theoretical investigation
of the programming language they used.

% 他の方法としてどのようなものが考えられたか

% Although we define type equivalence of \LMD with composition of equivalence rules,
% there is another candiate to define,
% which gives reduction on types and compare the results of reduction such as~\cite{sorensen2006lectures}.
% This method is better than one of \LMD because equivalence rules become simple.
% However, we reject it because it cannot handle CSP flexibly.
