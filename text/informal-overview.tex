% !TEX root = ../main.tex

\section{Informal Overview of \LMD \label{sec:informal-overview}}

We designed \LMD, a multi-stage calculus with dependent type.
\LMD is based on \LTP\cite{Hanada2014} by Hanada and Igarashi, which is a multi-stage calculus with CSP, and
we introduced dependent types based on \LTP\cite{attapl}.
In this section, we check \LMD informally after checking \LTP and \LLF which are the basis of \LMD.

% \red{\LTP\cite{Hanada2014}が頻発するが同一論文の複数回引用に何かルールはあるのか?}
% \AI{ないです．たしかにあんまりつけるとうるさいですね．2.1 の冒頭とかは文ごと不要なのでは？}
\subsection{\LTP}

% quote and unquote

In \LTP, brackets and escape are written $\TB_\alpha M$ and $\TBL_\alpha M$, respectively.
The type of $\TB_\alpha M$ is $\TW_\alpha \tau$ if $M$ has type $\tau$.
The type of $\TBL_\alpha M$ is $\tau$ if $M$ has $\TW_\alpha \tau$.
% Please notice that if $\TBL_\alpha M$ is well-typed, $M$ has a code type from the typing rule of \LTP.
In addition to normal $\beta$-reduction, there is a reduction rule for brackets and escape.
\begin{align*}
	\TBL_\alpha (\TB_\alpha M) \longrightarrow M 
\end{align*}
It means escape cancels brackets.
% This reduction is called $\longrightarrow_\Lambda$ in \LMD.
% \red{この文はここに来るべきなのか? LTPの説明ではないが}

% stage variable and stage

The subscript $\alpha$ in $\TB_\alpha M$ is a \textit{stage variable}
\footnote{In the original \LTP paper, this is called a \textit{transition variable}. 
However, we call it a \textit{stage variable} in this paper.} and
a sequence of stage variables is called \textit{stage}.
The empty stage is represented by $\varepsilon$.
They are used to show the depth of brackets.
For example, $\TB_\alpha (\lambda x:\I.x+10)$ is the fragment of code which becomes $(\lambda x:\I.x+10)$ after it was run once and
$\TB_\alpha \TB_\beta (\lambda x:\I.x+10)$, which is abbreviated as $\TB_{\alpha\beta} (\lambda x:\I.x+10)$,
becomes $(\lambda x:\I.x+10)$ after it was run it twice.

% stage abstraction and application

There are abstractions for stage variables and applications for stage abstraction in \LTP.
They look like $\Lambda\alpha.M$ and $M A$, respectively.
A stage abstraction binds a stage variable in a term.
For example, all $\alpha$ in $\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x))$ are bound.
There is a reduction rule for stage application in \LTP.
The rule is the following.
\begin{align*}
	(\Lambda\alpha.M)\ A \longrightarrow M[\alpha\mapsto A]
\end{align*}
For example, $\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x))\ (\beta\gamma)$ reduces to $\TB_{\beta\gamma} (\lambda x:\I.x)$.

% stage-related symbols disappear when the empty stage is substituted.
% In short, about "run"

Another important rule about a stage variable is 
that symbols with stage variables disappear 
when the empty stage $\varepsilon$ is substituted to the stage variable.
The purpose of this rule is express \verb|run| without any special symbol.
In multi-stage calculus, \verb|run| is a very important operator which changes quoted code to the original code.
For example, $(\TB_\varepsilon (\lambda x:\I.x))$ is equivalent to $(\lambda x:\I.x)$.
Therefore, $\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x))\ \varepsilon$ becomes $\lambda x:\I.x$
In \LTP, \verb|run| is realized with application to the empty stage $\varepsilon$.

% stage in typing rules

A type judgement of \LTP is of the form $\G \vdash M : \tau @ A$.
A stage in a judgement represents where the judgement is true.
For example, $\G \vdash (\lambda x:\I.x) : \I \to \I @ \alpha$ means 
term $\lambda x:\I.x$ has type $\I \to \I$ at stage $\alpha$.
Especially, terms without quoting exist at the empty stage $\varepsilon$.
For example, $(\lambda x:\I.x)\ (1+2)$ is at $\varepsilon$ stage and 
$\TB_\alpha (\lambda x:\I.x)$ is at $\alpha$ stage.
Terefore, stages appear in typing rules, too.
\begin{center}
	\infrule{\G\vdash M:\tau @{A\alpha}}{\G\vdash \TB_{\alpha}M:\TW_{\alpha}\tau @A}{\TTB} \andalso
	\infrule{\G\vdash M:\TW_{\alpha}\tau @A}{\G\vdash \TBL_{\alpha}M:\tau @{A\alpha}}{\TTBL}
\end{center}
\TTB, corresponding to brackets, means 
if $M$ is typed $\tau$ at stage $A\alpha$ then $\TB_{\alpha}M$, quoted $M$, is typed $\TW_{\alpha}\tau$ at $A$.
\TTBL\ is converse of \TTB.

% CSP

CSP, cross-stage persistence, is an important feature of \LTP.
It enables us to embed value at an outer stage into an inner stage.
In \LTP, CSP is written explicitly and $\%$ is a symbol dedicated to CSP
although MetaOCaml CSP is implicit and there is no symbol for CSP.
For example, the variable $x$ is cross-staged into a code value in the following expression.
\[\lambda x:\I.(\Lambda\alpha.(\TB_\alpha (\lambda y:\I.y+\%_\alpha x))\ \varepsilon)\ 10\]

% Omitting Residualization
% この段落は3章のM eのあとに、この制限の結果として...という形で入れる

% There is another important feature called program residualization in \LTP.
% It means that a generated code can be dumped into a file.
% We can load the dumped file and run it.
% The difficulty arises when program residualization is used with CSP.
% Transition variables are classified into two kinds in \LTP in order to deal with this difficulty.

\subsection{\LLF}

% \LLF
\LLF is a simple system of dependent types introduced in \cite{attapl}.
It is made from Edinburgh LF\cite{harper1993framework} by omitting signatures and include declarative equality judgements.
Hence, all constants and base types are declared in the signature.
The \LLF type theory generalizes simply typed lambda calculus
by replacing the function type $\tau\to\sigma$ with the dependent function type $\Pi x:\tau.\sigma$.

% Kind, Well-formed kind
In addition to ordinary typing rules like simply typed lambda calculus,
there are kinding rules, well-formed kinding rules, term equivalence rules, type equivalence rules, and kind equivalence rules in \LLF.
Kinding rules and well-formed kinding rules are 
introduced in order to prohibit making illegal types such as $\textrm{Vector}\ \textrm{true}$.
For a well-formed type $\tau$, $\G \vdash \tau :: K$ means that $\tau$ has a kind $K$ under the environment $\G$ and 
for a well-formed kind $K$, $\G \vdash K$ means that $K$ is a well-formed kind under an environment $\G$.

% Type Equality
Type equality rules are needed because the type equivalence is not obvious unlike simply typed lambda calculus.
For example, $\textrm{Vector}\ 7$ should be equivalent to $\textrm{Vector}\ (3+4)$
but they are not equivalent seemingly. Thus, we must define equivalence rules.
In \LLF, equivalence is expressed with a symbol of $\E$.
$\G \vdash M \E N$ means a term $M$ and a term $N$ are equivalent under the environment $\G$.
$\G \vdash \tau \E \sigma$ means a type $\tau$ and a type $\sigma$ are equivalent under the environment $\G$.
$\G \vdash K \E J$ means a kind $K$ and a kind $J$ are equivalent under the environment $\G$.

\subsection{Extending \LTP with Dependent Types}

Next, we develop \LMD by extending \LTP with \LLF-like dependent types.
There are three technical points in the extension from \LTP to \LMD.

% Constants and Base Types

First, the way of handling of constants and type-level constants is the difference between \LMD and \LTP.
We adopt a signature $\Sigma$ to handle constants and type-level constants.
This is because a signature simplifies kinding rules relating to type-level constants.
A signature $\Sigma$ is composed of pairs of a base type and its kind or a constant and its type.
For example, if you want to use boolean, $\Sigma = \B::*, \text{true}:\B, \text{false}:\B$

% Kidinding and Well-formed Kinding Rules

Second, we need kinding rules and well-formed kinding rules in order to extend \LMD with dependent types.
It was lucky that almost all rules are determined easily.
This is because multi-stage calculus and dependent types are almost orthogonal.
Therefore, we can get kinding rules and well-formed kinding rules of \LMD just by 
attaching stage anotations to ones of \LLF.
For example, \KAbs-LF is a kinding rule for a dependent type in \LLF and \KAbs\ is a corresponding one.
\begin{center}
	\infrule{\G\vdash \tau :: * \andalso \G,x:\tau @A\vdash \sigma::J}{\G\vdash(\Pi x:\tau.\sigma) :: (\Pi x:\tau.J)}{\KAbs-LF} \\[2mm]
	\infrule{\G\V \tau :: *@A \andalso \G,x:\tau @A\V \sigma::J@A}{\G\V(\Pi x:\tau.\sigma) :: (\Pi x:\tau.J)@A}{\KAbs} \\[2mm]
\end{center}

% Equivalence Rules

Third, we also need type equivalence rules in \LMD because its type system contains dependent types.
Although there are new primitives relating to stages which aren't in \LLF,
we can design all rules easily from the syntax or the reductions of \LMD except one equivalence rule about CSP..