% !TEX root = ../main.tex

\section{Informal Overview of \LMD}

We designed \LMD, a multi-stage calculus with dependent type.
\LMD is based on \LTP\cite{Hanada2014} by Hanada and Igarashi, which is a multi-stage calculus with CSP and
we introduced dependent types based on \LTP\cite{attapl}.
In this section, we check \LMD informally after checking \LTP and \LLF which are the basis of \LMD.

\red{\LTP\cite{Hanada2014}が頻発するが同一論文の複数回引用に何かルールはあるのか?}
\subsection{\LTP}

% quote and unquote

\LTP\cite{Hanada2014} is a multi-stage calculus with CSP by Hanada and Igarashi.
In \LTP, brackets and escape are written $\TB_\alpha M$ and $\TBL_\alpha M$, respectively.
The type of $\TB_\alpha M$ is $\TW_\alpha \tau$ if $M$ has type $\tau$.
The type of $\TBL_\alpha M$ is $\tau$ if $M$ has $\TW_\alpha \tau$.
% Please notice that if $\TBL_\alpha M$ is well-typed, $M$ has a code type from the typing rule of \LTP.
In addition to normal $\beta$-reduction, there is a reduction rule for brackets and escape.
\begin{align*}
	\TBL_\alpha (\TB_\alpha M) \longrightarrow M 
\end{align*}
It means escape cancels brackets.
% This reduction is called $\longrightarrow_\Lambda$ in \LMD.
% \red{この文はここに来るべきなのか? LTPの説明ではないが}

% transition variable and transition

The subscript $\alpha$ in $\TB_\alpha M$ is a \textit{transition variable} and
a sequence of transition variables is called \textit{transition}.
The empty transition is represented by $\varepsilon$.
They are used to show the thickness of brackets.
For example, $\TB_\alpha (\lambda x:\I.x+10)$ is the fragment of code which becomes $(\lambda x:\I.x+10)$ after it was run once and
$\TB_\alpha \TB_\beta (\lambda x:\I.x+10)$, which is abbreviated as $\TB_{\alpha\beta} (\lambda x:\I.x+10)$,
becomes $(\lambda x:\I.x+10)$ after it was run it twice.
\red{run twiceは表現が微妙}

% transition abstraction and application

There are abstractions for transition variables and applications for transition abstraction in \LTP.
They look like $\Lambda\alpha.M$ and $M A$, respectively.
A transition abstraction binds a transition variable in a term.
For example, all $\alpha$ in $\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x))$ are bound.
It is only natural there is a reduction rule for transition application in \LTP.
The rule is the following.
\begin{align*}
	(\Lambda\alpha.M)\ A \longrightarrow M[\alpha\mapsto A]
\end{align*}
For example, $\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x))\ (\beta\gamma)$ reduces to $\TB_{\beta\gamma} (\lambda x:\I.x)$.

% transition-related symbols disappear when the empty transition is substituted.
% In short, about "run"

Another important rule about a transition variable is 
that symbols with transition variables disappear 
when the empty transition $\varepsilon$ is substituted to the transition variable.
The purpose of this rule is express \verb|run| without any special symbol.
In multi-stage calculus, \verb|run| is a very important operator which changes quoted code to the original code.
For example, $(\TB_\varepsilon (\lambda x:\I.x))$ is equivalent to $(\lambda x:\I.x)$.
Therefore, $\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x))\ \varepsilon$ becomes $\lambda x:\I.x$
In \LTP, \verb|run| is realized with application to the empty transition $\varepsilon$.

% transition in typing rules

A type judgement of \LTP is of the form $\G \vdash M : \tau @ A$.
A transition in a judgement represents where the judgement is true.
For example, $\G \vdash (\lambda x:\I.x) : \I \to \I @ \alpha$ means 
term $\lambda x:\I.x$ has type $\I \to \I$ at transition $\alpha$.
Especially, terms without quoting exist at the empty transition $\varepsilon$.
For example, $(\lambda x:\I.x)\ (1+2)$ is at $\varepsilon$ transition and 
$\TB_\alpha (\lambda x:\I.x)$ is at $\alpha$ transition.
Terefore, transitions appear in typing rules, too.
\begin{center}
	\infrule{\G\vdash M:\tau @{A\alpha}}{\G\vdash \TB_{\alpha}M:\TW_{\alpha}\tau @A}{\TTB} \andalso
	\infrule{\G\vdash M:\TW_{\alpha}\tau @A}{\G\vdash \TBL_{\alpha}M:\tau @{A\alpha}}{\TTBL}
\end{center}
\TTB, corresponding to brackets, means 
if $M$ is typed $\tau$ at transition $A\alpha$ then $\TB_{\alpha}M$, quoted $M$, is typed $\TW_{\alpha}\tau$ at $A$.
\TTBL\ is converse of \TTB.

% CSP

CSP, cross-stage persistence, is an important feature of \LTP.
It enables us to embed value at an outer transition into an inner transition.
$\%$ is dedicated to CSP in \LTP.
For example, $\lambda a:\I.\Lambda\alpha.(\TB_\alpha (\lambda x:\I.x+\%_\alpha a))$
\red{inner / outer は適切か?}

% Omitting Residualization
% この段落は3章のM eのあとに、この制限の結果として...という形で入れる

% There is another important feature called program residualization in \LTP.
% It means that a generated code can be dumped into a file.
% We can load the dumped file and run it.
% The difficulty arises when program residualization is used with CSP.
% Transition variables are classified into two kinds in \LTP in order to deal with this difficulty.

\subsection{\LLF}

% \LLF
\LLF is a simple system of dependent types introduced in \cite{attapl}.
\red{system / type system / calculus?}
It is based on Edinburgh LF\cite{harper1993framework}.
Therefore, all constants and base types are declared in the signature.
The \LLF type theory generalizes simply typed lambda calculus
by replacing the function type $\tau\to\sigma$ with the dependent product type $\Pi x:\tau.\sigma$.

% Kind, Well-formed kind
In addition to ordinary typing rules like simply typed lambda calculus,
there are kinding rules, well-formed kinding rules, term equivalence rules, type equivalence rules, and kind equivalence rules in \LLF.
Kinding rules and well-formed kinding rules are 
introduced in order to prohibit making illegal types such as $\textrm{Vect}\ \textrm{Bool}$.
For a well-formed type $\tau$, $\G \vdash \tau :: K$ means that $\tau$ has a kind $K$ under the environment $\G$ and 
for a well-formed kind $K$, $\G \vdash K$ means that $K$ is a well-formed kind under an environment $\G$.

% Type Equality
Type equality rules are needed because the type equivalence is not obvious unlike simply typed lambda calculus.
For example, $\textrm{Vect}\ 7$ should be equivalent to $\textrm{Vect}\ (3+4)$
but they are not equivalent seemingly. Thus, we must define equivalence rules.
In \LLF, equivalence is expressed with a symbol of $\E$.
$\G \vdash M \E N$ means a term $M$ and a term $N$ are equivalent under the environment $\G$.
$\G \vdash \tau \E \sigma$ means a type $\tau$ and a type $\sigma$ are equivalent under the environment $\G$.
$\G \vdash K \E J$ means a kind $K$ and a kind $J$ are equivalent under the environment $\G$.

\subsection{Extending \LTP with Dependent Types}

Next, we develop \LMD by extending \LTP with \LLF-like dependent types.
From here, we use the word "stage" instead of "transition" 
because we develop a multi-stage calculus, not a multi-transition calculus.
\red{stageのほうが言葉としてふさわしいと言いたい}
There are three technical points in the extension from \LTP to \LMD.

% Constants and Base Types

First, the way of handling of constants and type-level constants is the difference between \LMD and \LTP.
We adopt a signature $\Sigma$ to handle constants and type-level constants.
This is because a signature simplifies kinding rules relating to type-level constants.
A signature $\Sigma$ is composed of pairs of a base type and its kind or a constant and its type.
For example, if you want to use boolean, $\Sigma = \B::*, \text{true}:\B, \text{false}:\B$
\red{具体的な導出例を出したほうがよいか? また、なぜsimpleになるのを書くべきか?}

% Kidinding and Well-formed Kinding Rules

Second, we need kinding rules and well-formed kinding rules in order to extend \LMD with dependent types.
It was lucky that almost all rules are determined easily.
This is because multi-stage calculus and dependent types are almost orthogonal.
\red{orthogonal は抽象的すぎるか?}
Therefore, we can get kinding rules and well-formed kinding rules of \LMD just by 
attaching stage anotations to ones of \LLF.
For example, \KAbs-LF is a kinding rule for a dependent type in \LLF and \KAbs\ is a corresponding one.
\begin{center}
	\infrule{\G\vdash \tau :: * \andalso \G,x:\tau @A\vdash \sigma::J}{\G\vdash(\Pi x:\tau.\sigma) :: (\Pi x:\tau.J)}{\KAbs-LF} \\[2mm]
	\infrule{\G\V \tau :: *@A \andalso \G,x:\tau @A\V \sigma::J@A}{\G\V(\Pi x:\tau.\sigma) :: (\Pi x:\tau.J)@A}{\KAbs} \\[2mm]
\end{center}

% Equivalence Rules

Third, we also need type equivalence rules in \LMD because its type system contains dependent types.
Although there are new primitives relating to stages which aren't in \LLF,
we can design all rules except \QPercent\ easily from the syntax or the reductions of \LMD.

\QPercent\ is different from other rules because it was designed from practical reason, not from the syntax or the reductions.
For example, we discuss $\text{vadd}_\beta$ function,
which takes a length of vector and returns addition function for vectors with the length.
$\text{vadd}_1$ is a helper function to make $\text{vadd}$, 
which takes a stage, a length of vectors, and two quoted vectors and returns a quoted vector.
We assumed that type checker can know $n=0$ when process the $\textbf{then}$ clause.
\newcommand{\Vpn}{\text{Vector}\ (\%_\alpha n)}
\begin{align*}
	  & \textbf{let}\ \text{vadd}_1 : \F\alpha.\Pi n:\I.\TW_\alpha\Vpn\to\TW_\alpha\Vpn\to\TW_\alpha\Vpn                                \\
	  & \hspace{7mm} = \textbf{fix}\ f.\Lambda\alpha.\lambda n:\I.\ \lambda v_1:\TW_\alpha\Vpn.\ \lambda v_2:\TW_\alpha\Vpn.            \\
	  & \hspace{14mm} \textbf{if}\ n = 0                                                                                                \\
	  & \hspace{14mm} \textbf{then} \TB_\alpha \text{nil}                                                                               \\
	  & \hspace{14mm} \textbf{else}\ \TB_\alpha (                                                                                       \\
	  & \hspace{21mm} \textbf{let}\ t_1 = \text{tail}\ (\TBL_\alpha v_1)\ \textbf{in}                                                   \\
	  & \hspace{21mm} \textbf{let}\ t_2 = \text{tail}\ (\TBL_\alpha v_2)\ \textbf{in}                                                   \\
	  & \hspace{21mm} \text{cons}\ (\text{head}\ (\TBL_\alpha v_1) + \text{head}\ (\TBL_\alpha v_2))\ (\TBL_\alpha f\ (n-1)\ t_1\ t_2)) \\
\end{align*}
Using $\text{vadd}_1$, we can make $\text{vadd}$ function easily.
This function takes the length of vectors and returns a quoted add function for vector of the given size.
\renewcommand{\Vpn}{\text{Vector}\ (\%_\beta n)}
\begin{align*}
	  & \textbf{let}\ \text{vadd}: \Pi n:\I.\F\beta.\TW_\beta(\Vpn\to\Vpn\to\Vpn)                \\ 
	  & \hspace{7mm} = \lambda n:\I.\Lambda\beta.\TB_\beta (\lambda v_1:\Vpn.\ \lambda v_2:\Vpn. \\
	  & \hspace{63mm} \TBL_\beta \text{vadd}_1\ \beta\ n\ (\TB_\beta\ v_1)\ (\TB_\beta\ v_2))    \\
\end{align*}
\renewcommand{\Vpn}{\text{Vector}\ (\%_\beta 10)}
When we use this function, we need to instantiate $\text{vadd}$ with a length.
If we instantiate it with a integer 10, we get function $\text{vadd10}$ whose type is \\
$\text{vadd10}: \F\beta.\TW_\beta(\Vpn\to\Vpn\to\Vpn)$.
This function is difficult to use because its type contains $\Vpn$.
In most cases, we have vectors of type $\text{Vector}\ 10$, not $\Vpn$.
Therefore, we want to identify $\text{Vector}\ 10$ and $\Vpn$.

In order to resolve this problem, we introduced \QPercent\ into \LMD.
\QPercent\ enables us to identify $\text{Vector}\ 10$ and $\Vpn$.
This rule says that if term $M$ has the same type at stage $A\alpha$ and $A$,
we can assume $\%_\alpha M \E M$ which roughly means $\%_\alpha M$ and $M$ are equivalent.
With this rule, we can identify $10$ and $\%_\beta 10$ and use $\text{vadd}$ to many vectors.
\begin{center}
	\infrule{\G\V M:\tau @{A\alpha} \andalso \G\V M:\tau @A}{\G\V\%_\alpha M \E M : \tau @{A\alpha}}{\QPercent}
\end{center}

