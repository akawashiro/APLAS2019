% !TEX root = ../main.tex

\section{Informal Overview of \LMD \label{sec:informal-overview}}

We describe our calculus \LMD informally.  \LMD is based on
\LTP~\cite{Hanada2014} by Hanada and Igarashi and we introduce
dependent types based on \LLF~\cite{attapl}.  We start with a review of 
\LTP.

% \red{\LTP\cite{Hanada2014}が頻発するが同一論文の複数回引用に何かルールはあるのか?}
% \AI{ないです．たしかにあんまりつけるとうるさいですね．2.1 の冒頭とかは文ごと不要なのでは？}
\subsection{\LTP}

% quote and unquote

In \LTP, brackets (quasi-quotation) and escape (unquote) are written
$\TB_\alpha M$ and $\TBL_\alpha M$, respectively.  For example,
$\TB_\alpha (1 + 1)$ represents code of expression $1 + 1$ and thus
evaluates to itself.  Escape $\TBL_\alpha M$ may appear under
$\TB_\alpha$; it evaluates $M$ to a code value and splice it into the
surrounding code fragment.  Such splicing is expressed by the
following reduction rule:
\begin{align*}
	\TBL_\alpha (\TB_\alpha M) \longrightarrow M 
\end{align*}
The type of
$\TB_\alpha M$ is $\TW_\alpha \tau$ if $M$ has type $\tau$; the type
of $\TBL_\alpha M$ is $\tau$ if $M$ has $\TW_\alpha \tau$.

The subscript $\alpha$ in $\TB_\alpha M$ is a \textit{stage variable}\footnote{%
  In Hanada and Igarash~\cite{Hanada2014}, it was called a \textit{transition variable}, which is derived from correspondence to modal logic, studied by Tsukada and Igarashi~\cite{Tsukada}.} and
a sequence of stage variables is called \textit{stage}.
Intuitively, they represent the depth of nested brackets.
Stage variables can be abstracted by $\Lambda\alpha.M$ and instantiated by
an application $M\ A$ to stages.
For example, $\Lambda\alpha.\TB_\alpha ((\lambda x:\I.x+10) 5)$ is a code value, where \(\alpha\)
is abstracted.  If it is applied to \(\varepsilon\), which is the empty sequence standing for zero,
\(\TB_\alpha\) becomes \(\TB_\varepsilon\), which stands for zero brackets,
and so \(\TB_\alpha\) disappears.  As a result, the application reduces to (unquoted) \((\lambda x:\I.x+10) 5\) and to 15.  If \(\alpha\) is instantiated with, say, \(\beta\gamma\), then
\(\TB_\alpha\) becomes nested brackets \(\TB_{\beta} \TB_\gamma\).  These are expressed by
the following reduction rule:
\begin{align*}
	(\Lambda\alpha.M)\ A \longrightarrow M[\alpha\mapsto A]
\end{align*}
where stage substitution \([\alpha \mapsto A]\) manipulates nesting of
\(\TB\) and \(\TBL\) (and also \(\%_\alpha\) as we see later).  As we
show above, application to $\varepsilon$ corresponds to \texttt{run}.

Cross-stage persistence (CSP), which is an important feature of \LTP,
is a primitive to embed values (not necessarily code values) into a
code value.
For example,
\begin{verbatim}
   let y = 1 + 2 in
   .< y * 2 >.    (* .< e >. stands for brackets *)
\end{verbatim}
evaluates to \verb|.< 3 * 2 >.|, not \verb|.< plusone 2 * 2 >.|.
Here, CSP is implicitly applied to the occurrence of \texttt{y}
and embeds its value \texttt{3} into the code.
In \LTP, CSP is written explicitly and $\%$ is a symbol for CSP.
For example, the above MetaOCaml expression can be expressed
in \LTP as follows:
\[
  (\lambda x:\I.\Lambda\alpha.(\TB_\alpha ((\%_\alpha y) * 2)))\ (1 + 2)
\]
It evaluates to \(\Lambda\alpha.(\TB_\alpha ((\%_\alpha 3) * 2))\), in
which $\%_\alpha 3$ means that it waits for the surrounding code to be
run (by an application to $\varepsilon$).  If it is applied to
\(\varepsilon\), substitution of \(\varepsilon\) for \(\alpha\)
eliminates \(\TB_\alpha\) and \(\%_\alpha\) and so \(3 * 2\) is
obtained.

The type system of \LTP uses code types---the type of code of type
\(\tau\) is written \(\TW_\alpha \tau\)---for typing \(\TB_\alpha\),
\(\TBL_\alpha\) and \(\%_\alpha\).  It takes stages into account: A
variable declaration in a type environment is associated with its
declared stage as well as its type and a type judgement of \LTP is of
the form $\G \vdash M : \tau @ A$, in which $A$ stands for the stage
of term $M$.  For example,
$y:\I@\alpha \vdash (\lambda x:\I.y) : \I \to \I @ \alpha$ holds, but
$y:\I@\alpha \vdash (\lambda x:\I.y) : \I \to \I @ \varepsilon$ does
not because the latter uses $y$ at stage \(\varepsilon\) but $y$ is
declared at $\alpha$.  Quotation \(\TB_\alpha M\) is given type
\(\TW_\alpha \tau\) at stage \(A\) if \(M\) is given type \(\tau\) at
stage \(A\alpha\) and  unquote \(\TBL_\alpha M\) is given type
\(\tau\) at stage \(A\alpha\) if \(M\) is given type \(\TW_\alpha \tau\) at
stage \(A\alpha\), represented by the following rules.
\begin{center}
	\infrule{\G\vdash M:\tau @{A\alpha}}{\G\vdash \TB_{\alpha}M:\TW_{\alpha}\tau @A}{\TTB} \andalso
	\infrule{\G\vdash M:\TW_{\alpha}\tau @A}{\G\vdash \TBL_{\alpha}M:\tau @{A\alpha}}{\TTBL}
\end{center}
% \TTB, corresponding to brackets, means 
% if $M$ is typed $\tau$ at stage $A\alpha$ then $\TB_{\alpha}M$, quoted $M$, is typed $\TW_{\alpha}\tau$ at $A$.
% \TTBL\ is converse of \TTB.

% CSP


% Omitting Residualization
% この段落は3章のM eのあとに、この制限の結果として...という形で入れる

% There is another important feature called program residualization in \LTP.
% It means that a generated code can be dumped into a file.
% We can load the dumped file and run it.
% The difficulty arises when program residualization is used with CSP.
% Transition variables are classified into two kinds in \LTP in order to deal with this difficulty.

\subsection{\LLF}

% \LLF
\LLF is a simple system of dependent types introduced in \cite{attapl}.
It is made from Edinburgh LF\cite{harper1993framework} by omitting signatures and include declarative equality judgements.
Hence, all constants and base types are declared in the signature.
The \LLF type theory generalizes simply typed lambda calculus
by replacing the function type $\tau\to\sigma$ with the dependent function type $\Pi x:\tau.\sigma$.

% Kind, Well-formed kind
In addition to ordinary typing rules like simply typed lambda calculus,
there are kinding rules, well-formed kinding rules, term equivalence rules, type equivalence rules, and kind equivalence rules in \LLF.
Kinding rules and well-formed kinding rules are 
introduced in order to prohibit making illegal types such as $\textrm{Vector}\ \textrm{true}$.
For a well-formed type $\tau$, $\G \vdash \tau :: K$ means that $\tau$ has a kind $K$ under the environment $\G$ and 
for a well-formed kind $K$, $\G \vdash K$ means that $K$ is a well-formed kind under an environment $\G$.

% Type Equality
Type equality rules are needed because the type equivalence is not obvious unlike simply typed lambda calculus.
For example, $\textrm{Vector}\ 7$ should be equivalent to $\textrm{Vector}\ (3+4)$
but they are not equivalent seemingly. Thus, we must define equivalence rules.
In \LLF, equivalence is expressed with a symbol of $\E$.
$\G \vdash M \E N$ means a term $M$ and a term $N$ are equivalent under the environment $\G$.
$\G \vdash \tau \E \sigma$ means a type $\tau$ and a type $\sigma$ are equivalent under the environment $\G$.
$\G \vdash K \E J$ means a kind $K$ and a kind $J$ are equivalent under the environment $\G$.

\subsection{Extending \LTP with Dependent Types}

\AI{We should discuss conceptual points, not technical points!}

Next, we develop \LMD by extending \LTP with \LLF-like dependent types.
There are three technical points in the extension from \LTP to \LMD.

% Constants and Base Types

First, the way of handling of constants and type-level constants is the difference between \LMD and \LTP.
We adopt a signature $\Sigma$ to handle constants and type-level constants.
This is because a signature simplifies kinding rules relating to type-level constants.
A signature $\Sigma$ is composed of pairs of a base type and its kind or a constant and its type.
For example, if you want to use boolean, $\Sigma = \B::*, \text{true}:\B, \text{false}:\B$

% Kidinding and Well-formed Kinding Rules

Second, we need kinding rules and well-formed kinding rules in order to extend \LMD with dependent types.
It was lucky that almost all rules are determined easily.
This is because multi-stage calculus and dependent types are almost orthogonal.
Therefore, we can get kinding rules and well-formed kinding rules of \LMD just by 
attaching stage anotations to ones of \LLF.
For example, \KAbs-LF is a kinding rule for a dependent type in \LLF and \KAbs\ is a corresponding one.
\begin{center}
	\infrule{\G\vdash \tau :: * \andalso \G,x:\tau @A\vdash \sigma::J}{\G\vdash(\Pi x:\tau.\sigma) :: (\Pi x:\tau.J)}{\KAbs-LF} \\[2mm]
	\infrule{\G\V \tau :: *@A \andalso \G,x:\tau @A\V \sigma::J@A}{\G\V(\Pi x:\tau.\sigma) :: (\Pi x:\tau.J)@A}{\KAbs} \\[2mm]
\end{center}

% Equivalence Rules

Third, we also need type equivalence rules in \LMD because its type system contains dependent types.
Although there are new primitives relating to stages which aren't in \LLF,
we can design all rules easily from the syntax or the reductions of \LMD except one equivalence rule about CSP..