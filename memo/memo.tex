% VS code setting
% Ctrl + Alt + B -> Build
% Ctrl + Alt + V -> Preview PDF file

\documentclass[9pt, a4paper]{extarticle}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bcprules, proof}
\usepackage{fancybox}
\usepackage{mathtools}
\usepackage{float}
\usepackage[truedimen,margin=15truemm]{geometry}
\usepackage{color}
\usepackage{xparse}
\usepackage{ebproof}
\usepackage{lscape}
\usepackage{mdframed}

% \theoremstyle{definition}
% \newtheoremstyle{break}
%   {\topsep}{\topsep}%
%   {\itshape}{}%
%   {\bfseries}{}%
%   {\newline}{}%

\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
% \newtheorem{thm}{Theorem}
\newmdtheoremenv{thm}{Theorem}
\newmdtheoremenv{lemma}{Lemma}
\newmdtheoremenv{theorem}{Theorem}
\newmdtheoremenv{dfn}{Definition}
\newtheorem{ex}{Example}
\newtheorem{cm}{Comment}

\newif\iffullversion
\fullversiontrue

\newcommand{\rulefbox}[1]{\fbox{\ensuremath{#1}} \hspace{1mm}}

\newcommand{\figheader}[2]{
  \begin{flushleft}
    #2 {\bf \normalsize #1}
\end{flushleft}}

\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}
\newcommand{\V}{\vdash_\Sigma}
\newcommand{\VT}{\vdash\hspace{-.50em}\raisebox{0.28em}{\tiny{$\TB$}}}
\newcommand{\iskind}{\text{\ kind}}
\newcommand{\TW}{\triangleright}
\newcommand{\TWL}{\triangleleft}
\newcommand{\F}{\forall}
\newcommand{\TB}{\blacktriangleright}
\newcommand{\TBL}{\blacktriangleleft}
\newcommand{\E}{\equiv}
\newcommand{\FV}{\text{FV}}
\newcommand{\FTV}{\text{FTV}}

\newcommand{\WStar}{\textsc{W-Star}}
\newcommand{\WAbs}{\textsc{W-Abs}}
\newcommand{\WCsp}{\textsc{W-Csp}}
\newcommand{\WApp}{\textsc{W-App}}
\newcommand{\WTW}{\textsc{W-$\TW$}}

\newcommand{\KVar}{\textsc{K-Var}}
\newcommand{\KAbs}{\textsc{K-Abs}}
\newcommand{\KApp}{\textsc{K-App}}
\newcommand{\KConv}{\textsc{K-Conv}}
\newcommand{\KTW}{\textsc{K-$\TW$}}
\newcommand{\KTWL}{\textsc{K-$\TWL$}}
\newcommand{\KGen}{\textsc{K-Gen}}
\newcommand{\KCsp}{\textsc{K-Csp}}

\newcommand{\TConst}{\textsc{T-Const}}
\newcommand{\TVar}{\textsc{T-Var}}
\newcommand{\TAbs}{\textsc{T-Abs}}
\newcommand{\TApp}{\textsc{T-App}}
\newcommand{\TConv}{\textsc{T-Conv}}
\newcommand{\TTB}{\textsc{T-$\TB$}}
\newcommand{\TTBL}{\textsc{T-$\TBL$}}
\newcommand{\TGen}{\textsc{T-Gen}}
\newcommand{\TIns}{\textsc{T-Ins}}
\newcommand{\TCsp}{\textsc{T-Csp}}

\newcommand{\QKAbs}{\textsc{QK-Abs}}
\newcommand{\QKCsp}{\textsc{QK-Csp}}
\newcommand{\QKRefl}{\textsc{QK-Refl}}
\newcommand{\QKSym}{\textsc{QK-Sym}}
\newcommand{\QKTrans}{\textsc{QK-Trans}}

\newcommand{\QTAbs}{\textsc{QT-Abs}}
\newcommand{\QTApp}{\textsc{QT-App}}
\newcommand{\QTTW}{\textsc{QT-$\TW$}}
\newcommand{\QTGen}{\textsc{QT-Gen}}
\newcommand{\QTCsp}{\textsc{QT-Csp}}
\newcommand{\QTRefl}{\textsc{QT-Refl}}
\newcommand{\QTSym}{\textsc{QT-Sym}}
\newcommand{\QTTrans}{\textsc{QT-Trans}}

\newcommand{\QAbs}{\textsc{Q-Abs}}
\newcommand{\QApp}{\textsc{Q-App}}
\newcommand{\QTB}{\textsc{Q-$\TB$}}
\newcommand{\QTBL}{\textsc{Q-$\TBL$}}
\newcommand{\QGen}{\textsc{Q-Gen}}
\newcommand{\QIns}{\textsc{Q-Ins}}
\newcommand{\QCsp}{\textsc{Q-Csp}}
\newcommand{\QRefl}{\textsc{Q-Refl}}
\newcommand{\QSym}{\textsc{Q-Sym}}
\newcommand{\QTrans}{\textsc{Q-Trans}}
\newcommand{\QBeta}{\textsc{Q-$\beta$}}
\newcommand{\QEta}{\textsc{Q-$\eta$}}
\newcommand{\QTBLTB}{\textsc{Q-$\TBL\TB$}}
\newcommand{\QLambda}{\textsc{Q-$\Lambda$}}
\newcommand{\QPercent}{\textsc{Q-\%}}

\newcommand{\ID}[1]{\infer[]{#1}{\vdots}}
\newcommand{\MD}[1]{\mathcal{D}_#1}

\newcommand{\red}[1]{\textcolor{red}{ #1 }}
\newcommand{\blue}[1]{\textcolor{blue}{ #1 }}

\newcommand{\AI}[1]{\textcolor{red}{[#1 -- AI]}}

\title{Multistage Programming with Dependent Type}

\author{Akira KAWATA}
\date{\today}

\begin{document}

\maketitle

\red{Red part means ommision.}

\blue{Blue part means just a comment.}

\section{ $ \lambda^{\text{MD}} $ }

\input{text/fulldefinition}

\figheader{Example}{}

\begin{ex}
	\newcommand{\M}{\textrm{M}}
	\newcommand{\I}{\textrm{Int}}
	\newcommand{\Vn}{\text{Vector}\ (\%_\alpha n)}
	\begin{align*}
		 & \textbf{let}\ \text{vadd}_1 : \Pi n:\I.\TW_\alpha\Vn\to\TW_\alpha\Vn\to\TW_\alpha\Vn               \\
		 & \hspace{7mm} = \textbf{fix}\ f.\lambda n:\I.\ \lambda v_1:\TW_\alpha\Vn.\ \lambda v_2:\TW_\alpha\Vn.   \\
		 & \hspace{14mm} \textbf{if}\ n = 0                                                                   \\
		 & \hspace{14mm} \textbf{then} \TB_\alpha \text{nil}                                                  \\
		 & \hspace{14mm} \textbf{else}\ \TB_\alpha (                                                          \\
		 & \hspace{21mm} \textbf{let}\ t_1 = \text{tail}\ (\TBL_\alpha v_1)\ \textbf{in}                      \\
		 & \hspace{21mm} \textbf{let}\ t_2 = \text{tail}\ (\TBL_\alpha v_2)\ \textbf{in}                      \\
		 & \hspace{21mm} \text{cons}\ (\text{head}\ t_1 + \text{head}\ t_2) (\TBL_\alpha f\ (n-1)\ t_1\ t_2)) \\
	\end{align*}
	\begin{align*}
		 & \textbf{let}\ \text{vadd}_\alpha : \Pi n:\I.\TW_\alpha(\Vn\to\Vn\to\Vn)              \\
		 & \hspace{7mm} = \lambda n:\I.\TB_\alpha (\lambda v_1:\Vn.\ \lambda v_2:\Vn. \TBL_\alpha \text{vadd}_1\ n\ (\TB_\alpha v_1)\ (\TB_\alpha v_2)) \\
	\end{align*}
\end{ex}

\iffullversion
	\begin{ex}
		\newcommand{\M}{\textrm{M}}
		\newcommand{\I}{\textrm{I}}
		% \newcommand{\GF}{\textrm{GF}}
		An example of CSP using \%
		\begin{align*}
			\I::*@\varepsilon,\bar{5}:\I@\alpha\V ((\lambda(f:\Pi x:\I.\I).\TB_\alpha (\%_\alpha f\ \bar{5}))\ (\lambda x:\I.x)) : \TW_\alpha \I@\varepsilon
		\end{align*}

		Type derivation is following.\\
		Set $\G$ as $\I::*@\varepsilon,\bar{5}:\I@\alpha$.
		\begin{center}
			$$
				\infer[\textsc{T-App}]
				{\G\V (\lambda(f:\Pi (x:\I).\I).\TB_\alpha (\%_\alpha f\ \bar{5}))\ (\lambda x:\I.x) : \TW_\alpha\I@\varepsilon}
				{\infer[\textsc{T-Abs}]
					{\G\V (\lambda(f:\Pi (x:\I).\I).\TB_\alpha (\%_\alpha f\ \bar{5})):\Pi (f:\Pi (x:\I).\I).\TW_\alpha \I@\varepsilon}
					{\infer[\textsc{T-$\TB$}]
						{\G ,f:\Pi (x:\I).\I@\varepsilon \V \TB_\alpha (\%_\alpha f\ \bar{5})):\TW_\alpha \I@\varepsilon}
						{\infer[\textsc{T-App}]
							{\G ,f:\Pi (x:\I).\I@\varepsilon \V\%_\alpha f\ \bar{5}: \I@\alpha}
							{\infer[\textsc{T-Csp}]
								{\G ,f:\Pi (x:\I).\I@\varepsilon \V \%_\alpha f\ : \Pi (x:\I).\I@\alpha}
								{\infer[]{\G ,f:\Pi (x:\I).\I@\varepsilon \V f: \Pi (x:\I).\I@\varepsilon}{\vdots}}
								\andalso
								\infer[]
								{\G\ldots \V \bar{5}: \I@\alpha}
								{\vdots}
							}
						}
					}\andalso
					\infer[\textsc{T-Abs}]
					{\G\V(\lambda x:\I.x):\Pi (x:\I).\I@\varepsilon}
					{
						\infer[]{\G,x:\I@\varepsilon\V x:\I@\varepsilon}{\vdots} \andalso \infer[]{\I::*@\varepsilon,\bar{5}:\I@\alpha\V\I::*@\varepsilon}{\vdots}}}
			$$
		\end{center}
	\end{ex}

	\begin{ex}
		\newcommand{\M}{\textrm{M}}
		\newcommand{\MM}{\textrm{M}\ 13}
		\newcommand{\I}{\textrm{I}}
		We can type this example, because $(\%_\alpha\ 13) \E 13$.\\
		\begin{align*}
			\I::*@\varepsilon,\M::(\Pi (x:\I).*)@\varepsilon,13:\I@\varepsilon,13:\I@\alpha,\bar{5}:\M\ 13@\varepsilon\V\TB_\alpha ((\lambda (y:\M (\%_\alpha 13)).y)\ \bar{5}):\TW_\alpha \M\ 13@\alpha
		\end{align*}

		Type derivation is following.\\
		Set $\G$ as $\I::*@\varepsilon,\M::(\Pi (x:\I).*)@\varepsilon,13:\I@\varepsilon,13:\I@\alpha,\bar{5}:\M\ 13@\alpha$.\\
		Set $p_1$ as $\G,y:\M (\%_\alpha 13)@\alpha \V y:\M (\%_\alpha 13)@\alpha$.\\
		Set $p_2$ as $\G,y:\M (\%_\alpha 13)@\alpha \V \M (\%_\alpha 13)\E\MM@\alpha$.
		\begin{center}
			$$
				\infer[\textsc{T-$\TB$}]
				{\G\V\TB_\alpha ((\lambda (y:\M (\%_\alpha 13)).y)\ \bar{5}):\TW_\alpha \MM@\varepsilon}
				{
					\infer[\textsc{T-App}]
					{\G\V (\lambda (y:\M (\%_\alpha 13)).y)\ \bar{5}:\M\ 13@\alpha}
					{
						\infer[\textsc{T-Abs}]
						{\G\V (\lambda (y:\M (\%_\alpha 13)).y):\Pi (y:\MM).\M\ 13@\alpha}
						{
							\infer[\textsc{T-Conv}]
							{\G,y:\M (\%_\alpha 13)@\alpha \V y:\MM@\alpha}
							{\infer[]{p_1}{\textrm{(goto label-$p_1$)}} \andalso \infer[]{p_2}{\textrm{(goto label-$p_2$)}}}
							\andalso
							\infer[\textsc{K-Csp}]
							{\G\V \M (\%_\alpha 13):*@\alpha}
							{
								\infer[]
								{\G\V \M (\%_\alpha 13):*@\varepsilon}
								{\vdots}
							}
						}
						\andalso
						\infer[]
						{\G\V \bar{5}:\MM@\alpha}
						{\vdots}
					}
				}
			$$
		\end{center}
		label-$p_1$:\\
		Set $\G'$ as $\I::*@\varepsilon,\M::(\Pi (x:\I).*)@\varepsilon,13:\I@\varepsilon,13:\I@\alpha,\bar{5}:\M\ 13@\alpha,y:\M (\%_\alpha 13)@\alpha$.\\
		Type derivation of $p_1$.
		\begin{center}
			$$
				\infer[\textsc{T-Var}]
				{\G,y:\M (\%_\alpha 13)@\alpha \V y:\M (\%_\alpha 13)@\alpha}
				{
					\infer[\textsc{K-App}]
					{\G' \V \M (\%_\alpha 13)::*@\alpha}
					{
						\infer[\textsc{K-Csp}]
						{\G'\V \M::\Pi (x:\I).*@\alpha}
						{
							\infer[]
							{\G'\V \M::\Pi (x:\I).*@\varepsilon}
							{\vdots}
						}
						\andalso
						\infer[\textsc{T-Csp}]
						{\G'\V (\%_\alpha 13):\I@\alpha}
						{
							\infer[]
							{\G'\V 13:\I@\varepsilon}
							{\vdots}
							\andalso
						}
					}
				}
			$$
		\end{center}
		label-$p_2$:\\
		{\bf{Type derivation of $p_2$}.}\\
		Set $\G'$ as $\I::*@\varepsilon,\M::(\Pi (x:\I).*)@\varepsilon,13:\I@\varepsilon,13:\I@\alpha,\bar{5}:\M\ 13@\alpha,y:\M (\%_\alpha 13)@\alpha$.\\
		abbr. means abbreviation defined in the top of page 1.
		\begin{center}
			$$
				\infer[\textsc{QT-App}]
				{\G,y:\M (\%_\alpha 13)@\alpha \V \M (\%_\alpha 13)\E\MM@\alpha}
				{
					\infer[\textrm{abbr.}]
					{\G' \V \M\E\M::(\Pi (x:\I).*)@\alpha}
					{
						\infer[\textsc{QT-Csp}]
						{\G' \V \M\E\M@\alpha}
						{
							\infer[\textsc{QT-Refl}]
							{\G\V \M\E\M@\varepsilon}
							{
								\infer[]
								{\G\V \M::(\Pi (x:\I).*)@\varepsilon}
								{
									\vdots
								}
							}
						}
						\andalso
						\infer[\textsc{K-Csp}]
						{\G' \V \M::(\Pi (x:\I).*)@\alpha}
						{
							\infer[]
							{\G \V\M::(\Pi (x:\I).*)@\varepsilon}
							{\vdots}
						}
					}
					\andalso
					\infer[\textrm{abbr.}]
					{\G' \V (\%_\alpha 13)\E 13:\I@\alpha}
					{
						\infer[\textsc{Q-\%}]
						{\G' \V (\%_\alpha 13)\E 13@\alpha}
						{
							\infer[\textsc{Q-\%}]
							{\G' \V (\%_\alpha 13):\I@\alpha}
							{
								\infer[]
								{\G' \V 13:\I@\varepsilon}
								{\vdots}
							}
							\andalso
							\infer[]
							{\G' \V 13:\I@\alpha}
							{\vdots}
						}
						\andalso
						\infer[]
						{\G' \V 13:\I@\alpha}
						{\vdots}
					}
				}
			$$
		\end{center}
	\end{ex}

	\begin{ex}
		\newcommand{\M}{\textrm{Mod}}
		\newcommand{\I}{\textrm{Int}}
		\newcommand{\GF}{\textrm{GF}}
		We cannot type this example, because $(\%_\alpha\ x) \not\E 13$.\\
		More precisely, our type equivalence rule cannot capture the information that "$x$ is bound to $13$".\\

		Set $\G$ as $\I::*@\varepsilon,\M::(\Pi (x:\I).*)@\varepsilon,13:\I@\varepsilon,\bar{5}:\M\ 13@\alpha$.
		\begin{align*}
			\G\V
			(\lambda (x:\I).
			(\TB_\alpha ((\lambda (y:\M (\%_\alpha x)).y)\ \bar{5})))\ 13):\TW_\alpha \M\ 13@\varepsilon
		\end{align*}
	\end{ex}

	\begin{ex}
		\newcommand{\I}{\textrm{Int}}
		\newcommand{\B}{\textrm{Bool}}
		\newcommand{\RI}{\textrm{RInt}}
		\newcommand{\rI}{\textrm{rInt}}
		\rI\ is a primitive function with a type of $\rI : \I \to (\RI\ \text{true})$.\\
		\RI\ is a primitive type constructor with a kind of $\RI : \B \to *$.
		\begin{align*}
			\text{let}\  & power3\ n = \hdots                                                                                  \\
			             & power3 : \forall\alpha. \TW_\alpha(\I \to \I)                                                       \\
			\text{let}\  & tested\_power3\ x = (\rI\ ((power3\ \varepsilon)\ x))                                               \\
			             & tested\_power3 : \I \to (\RI\ ((power3\ \varepsilon)\ 2 == 8\ \&\&\ (power3\ \varepsilon)\ 1 == 1)) \\
		\end{align*}
		When you use $tested\_power3$, it is guranteed that $tested\_power3$ pass the test.
	\end{ex}

	\begin{ex}
		\newcommand{\I}{\textrm{Int}}
		\newcommand{\Exp}{\textrm{Str}}
		\newcommand{\RI}{\textrm{RFun}}
		\newcommand{\rI}{\textrm{rFun}}
		\rI\ is a primitive function with a type of $\rI : (\forall\alpha.\TW_\alpha(\I \to \I)) \to (\RI\ \text{true})$.\\
		== between codes is a primitive function which return true for $\alpha$ equivalence pair.
		\begin{align*}
			\text{let}\  & staged\_intepreter\ str = \hdots                                                                                                \\
			             & staged\_intepreter : \Exp \to \forall\alpha.\TW_\alpha(\I \to \I)                                                               \\
			\text{let}\  & tested\_staged\_intepreter\ str = (\rI\ (staged\_intepreter\ str))                                                              \\
			             & tested\_staged\_intepreter : \Exp \to (\RI\ (staged\_intepreter\ "\lambda x:\I.x" == \Lambda\alpha.\TB_\alpha (\lambda x:\I.x)) \\
		\end{align*}
	\end{ex}

	\begin{ex}
		\newcommand{\I}{\textrm{Int}}
		\newcommand{\M}{\textrm{Mat}}
		\begin{align*}
			\text{mulmat}       & : \Pi x:\I.\Pi y:\I.(\TW_\alpha \Pi z:\I.(\M\ z\ \%_\alpha y) \to (\M\ \%_\alpha y\ \%_\alpha x) \to (\M\ z\ \%_\alpha x)) \\
			\text{mulmat}\ 3\ 5 & : \TW_\alpha \Pi z:\I.(\M\ z\ \%_\alpha 5) \to (\M\ \%_\alpha 5\ \%_\alpha 3) \to (\M\ z\ \%_\alpha 3)                     \\
			                    & (\E \TW_\alpha \Pi z:\I.(\M\ z\ 5) \to (\M\ 5\ 3) \to (\M\ z\ 3) )                                                         \\
		\end{align*}
	\end{ex}

\fi

\figheader{Theorem}{}

\input{text/proofs}

\end{document}
